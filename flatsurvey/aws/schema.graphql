# A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
input BooleanFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Boolean

  # Not equal to the specified value.
  notEqualTo: Boolean

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Boolean

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Boolean

  # Included in the specified list.
  in: [Boolean!]

  # Not included in the specified list.
  notIn: [Boolean!]

  # Less than the specified value.
  lessThan: Boolean

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Boolean

  # Greater than the specified value.
  greaterThan: Boolean

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Boolean
}

type BoshernitzanConjecture implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: UUID!
  timestamp: Datetime!
  surface: UUID
  data: JSON!

  # Reads a single `Surface` that is related to this `BoshernitzanConjecture`.
  surfaceBySurface: Surface
  assertion: String
}

# A condition to be used against `BoshernitzanConjecture` object types. All fields
# are tested for equality and combined with a logical ‘and.’
input BoshernitzanConjectureCondition {
  # Checks for equality with the object’s `id` field.
  id: UUID

  # Checks for equality with the object’s `timestamp` field.
  timestamp: Datetime

  # Checks for equality with the object’s `surface` field.
  surface: UUID

  # Checks for equality with the object’s `data` field.
  data: JSON
}

# A filter to be used against `BoshernitzanConjecture` object types. All fields are combined with a logical ‘and.’
input BoshernitzanConjectureFilter {
  # Filter by the object’s `id` field.
  id: UUIDFilter

  # Filter by the object’s `timestamp` field.
  timestamp: DatetimeFilter

  # Filter by the object’s `surface` field.
  surface: UUIDFilter

  # Filter by the object’s `data` field.
  data: JSONFilter

  # Filter by the object’s `assertion` field.
  assertion: StringFilter

  # Filter by the object’s `surfaceBySurface` relation.
  surfaceBySurface: SurfaceFilter

  # A related `surfaceBySurface` exists.
  surfaceBySurfaceExists: Boolean

  # Checks for all expressions in this list.
  and: [BoshernitzanConjectureFilter!]

  # Checks for any expressions in this list.
  or: [BoshernitzanConjectureFilter!]

  # Negates the expression.
  not: BoshernitzanConjectureFilter
}

# An input for mutations affecting `BoshernitzanConjecture`
input BoshernitzanConjectureInput {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON!
}

# Represents an update to a `BoshernitzanConjecture`. Fields that are set will be updated.
input BoshernitzanConjecturePatch {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON
}

# A connection to a list of `BoshernitzanConjecture` values.
type BoshernitzanConjecturesConnection {
  # A list of `BoshernitzanConjecture` objects.
  nodes: [BoshernitzanConjecture]!

  # A list of edges which contains the `BoshernitzanConjecture` and cursor to aid in pagination.
  edges: [BoshernitzanConjecturesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `BoshernitzanConjecture` you could get from the connection.
  totalCount: Int!
}

# A `BoshernitzanConjecture` edge in the connection.
type BoshernitzanConjecturesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `BoshernitzanConjecture` at the end of the edge.
  node: BoshernitzanConjecture
}

# Methods to use when ordering `BoshernitzanConjecture`.
enum BoshernitzanConjecturesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  SURFACE_ASC
  SURFACE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type CompletelyCylinderPeriodic implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: UUID!
  timestamp: Datetime!
  surface: UUID
  data: JSON!

  # Reads a single `Surface` that is related to this `CompletelyCylinderPeriodic`.
  surfaceBySurface: Surface
}

# A condition to be used against `CompletelyCylinderPeriodic` object types. All
# fields are tested for equality and combined with a logical ‘and.’
input CompletelyCylinderPeriodicCondition {
  # Checks for equality with the object’s `id` field.
  id: UUID

  # Checks for equality with the object’s `timestamp` field.
  timestamp: Datetime

  # Checks for equality with the object’s `surface` field.
  surface: UUID

  # Checks for equality with the object’s `data` field.
  data: JSON
}

# A filter to be used against `CompletelyCylinderPeriodic` object types. All fields are combined with a logical ‘and.’
input CompletelyCylinderPeriodicFilter {
  # Filter by the object’s `id` field.
  id: UUIDFilter

  # Filter by the object’s `timestamp` field.
  timestamp: DatetimeFilter

  # Filter by the object’s `surface` field.
  surface: UUIDFilter

  # Filter by the object’s `data` field.
  data: JSONFilter

  # Filter by the object’s `surfaceBySurface` relation.
  surfaceBySurface: SurfaceFilter

  # A related `surfaceBySurface` exists.
  surfaceBySurfaceExists: Boolean

  # Checks for all expressions in this list.
  and: [CompletelyCylinderPeriodicFilter!]

  # Checks for any expressions in this list.
  or: [CompletelyCylinderPeriodicFilter!]

  # Negates the expression.
  not: CompletelyCylinderPeriodicFilter
}

# An input for mutations affecting `CompletelyCylinderPeriodic`
input CompletelyCylinderPeriodicInput {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON!
}

# Represents an update to a `CompletelyCylinderPeriodic`. Fields that are set will be updated.
input CompletelyCylinderPeriodicPatch {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON
}

# A connection to a list of `CompletelyCylinderPeriodic` values.
type CompletelyCylinderPeriodicsConnection {
  # A list of `CompletelyCylinderPeriodic` objects.
  nodes: [CompletelyCylinderPeriodic]!

  # A list of edges which contains the `CompletelyCylinderPeriodic` and cursor to aid in pagination.
  edges: [CompletelyCylinderPeriodicsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `CompletelyCylinderPeriodic` you could get from the connection.
  totalCount: Int!
}

# A `CompletelyCylinderPeriodic` edge in the connection.
type CompletelyCylinderPeriodicsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `CompletelyCylinderPeriodic` at the end of the edge.
  node: CompletelyCylinderPeriodic
}

# Methods to use when ordering `CompletelyCylinderPeriodic`.
enum CompletelyCylinderPeriodicsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  SURFACE_ASC
  SURFACE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# All input for the create `BoshernitzanConjecture` mutation.
input CreateBoshernitzanConjectureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `BoshernitzanConjecture` to be created by this mutation.
  boshernitzanConjecture: BoshernitzanConjectureInput!
}

# The output of our create `BoshernitzanConjecture` mutation.
type CreateBoshernitzanConjecturePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `BoshernitzanConjecture` that was created by this mutation.
  boshernitzanConjecture: BoshernitzanConjecture

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `BoshernitzanConjecture`.
  surfaceBySurface: Surface

  # An edge for our `BoshernitzanConjecture`. May be used by Relay 1.
  boshernitzanConjectureEdge(
    # The method to use when ordering `BoshernitzanConjecture`.
    orderBy: [BoshernitzanConjecturesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BoshernitzanConjecturesEdge
}

# All input for the create `CompletelyCylinderPeriodic` mutation.
input CreateCompletelyCylinderPeriodicInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `CompletelyCylinderPeriodic` to be created by this mutation.
  completelyCylinderPeriodic: CompletelyCylinderPeriodicInput!
}

# The output of our create `CompletelyCylinderPeriodic` mutation.
type CreateCompletelyCylinderPeriodicPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `CompletelyCylinderPeriodic` that was created by this mutation.
  completelyCylinderPeriodic: CompletelyCylinderPeriodic

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `CompletelyCylinderPeriodic`.
  surfaceBySurface: Surface

  # An edge for our `CompletelyCylinderPeriodic`. May be used by Relay 1.
  completelyCylinderPeriodicEdge(
    # The method to use when ordering `CompletelyCylinderPeriodic`.
    orderBy: [CompletelyCylinderPeriodicsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompletelyCylinderPeriodicsEdge
}

# All input for the create `CylinderPeriodicAsymptotic` mutation.
input CreateCylinderPeriodicAsymptoticInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `CylinderPeriodicAsymptotic` to be created by this mutation.
  cylinderPeriodicAsymptotic: CylinderPeriodicAsymptoticInput!
}

# The output of our create `CylinderPeriodicAsymptotic` mutation.
type CreateCylinderPeriodicAsymptoticPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `CylinderPeriodicAsymptotic` that was created by this mutation.
  cylinderPeriodicAsymptotic: CylinderPeriodicAsymptotic

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `CylinderPeriodicAsymptotic`.
  surfaceBySurface: Surface

  # An edge for our `CylinderPeriodicAsymptotic`. May be used by Relay 1.
  cylinderPeriodicAsymptoticEdge(
    # The method to use when ordering `CylinderPeriodicAsymptotic`.
    orderBy: [CylinderPeriodicAsymptoticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CylinderPeriodicAsymptoticsEdge
}

# All input for the create `FlowDecomposition` mutation.
input CreateFlowDecompositionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FlowDecomposition` to be created by this mutation.
  flowDecomposition: FlowDecompositionInput!
}

# The output of our create `FlowDecomposition` mutation.
type CreateFlowDecompositionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FlowDecomposition` that was created by this mutation.
  flowDecomposition: FlowDecomposition

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `FlowDecomposition`.
  surfaceBySurface: Surface

  # An edge for our `FlowDecomposition`. May be used by Relay 1.
  flowDecompositionEdge(
    # The method to use when ordering `FlowDecomposition`.
    orderBy: [FlowDecompositionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FlowDecompositionsEdge
}

# All input for the create `OrbitClosure` mutation.
input CreateOrbitClosureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `OrbitClosure` to be created by this mutation.
  orbitClosure: OrbitClosureInput!
}

# The output of our create `OrbitClosure` mutation.
type CreateOrbitClosurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `OrbitClosure` that was created by this mutation.
  orbitClosure: OrbitClosure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `OrbitClosure`.
  surfaceBySurface: Surface

  # An edge for our `OrbitClosure`. May be used by Relay 1.
  orbitClosureEdge(
    # The method to use when ordering `OrbitClosure`.
    orderBy: [OrbitClosuresOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrbitClosuresEdge
}

# All input for the create `Surface` mutation.
input CreateSurfaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Surface` to be created by this mutation.
  surface: SurfaceInput!
}

# The output of our create `Surface` mutation.
type CreateSurfacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Surface` that was created by this mutation.
  surface: Surface

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Surface`. May be used by Relay 1.
  surfaceEdge(
    # The method to use when ordering `Surface`.
    orderBy: [SurfacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SurfacesEdge
}

# All input for the create `UndeterminedIntervalExchangeTransformation` mutation.
input CreateUndeterminedIntervalExchangeTransformationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `UndeterminedIntervalExchangeTransformation` to be created by this mutation.
  undeterminedIntervalExchangeTransformation: UndeterminedIntervalExchangeTransformationInput!
}

# The output of our create `UndeterminedIntervalExchangeTransformation` mutation.
type CreateUndeterminedIntervalExchangeTransformationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UndeterminedIntervalExchangeTransformation` that was created by this mutation.
  undeterminedIntervalExchangeTransformation: UndeterminedIntervalExchangeTransformation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `UndeterminedIntervalExchangeTransformation`.
  surfaceBySurface: Surface

  # An edge for our `UndeterminedIntervalExchangeTransformation`. May be used by Relay 1.
  undeterminedIntervalExchangeTransformationEdge(
    # The method to use when ordering `UndeterminedIntervalExchangeTransformation`.
    orderBy: [UndeterminedIntervalExchangeTransformationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UndeterminedIntervalExchangeTransformationsEdge
}

# All input for the create `User` mutation.
input CreateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `User` to be created by this mutation.
  user: UserInput!
}

# The output of our create `User` mutation.
type CreateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was created by this mutation.
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

type CylinderPeriodicAsymptotic implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: UUID!
  timestamp: Datetime!
  surface: UUID
  data: JSON!

  # Reads a single `Surface` that is related to this `CylinderPeriodicAsymptotic`.
  surfaceBySurface: Surface
}

# A condition to be used against `CylinderPeriodicAsymptotic` object types. All
# fields are tested for equality and combined with a logical ‘and.’
input CylinderPeriodicAsymptoticCondition {
  # Checks for equality with the object’s `id` field.
  id: UUID

  # Checks for equality with the object’s `timestamp` field.
  timestamp: Datetime

  # Checks for equality with the object’s `surface` field.
  surface: UUID

  # Checks for equality with the object’s `data` field.
  data: JSON
}

# A filter to be used against `CylinderPeriodicAsymptotic` object types. All fields are combined with a logical ‘and.’
input CylinderPeriodicAsymptoticFilter {
  # Filter by the object’s `id` field.
  id: UUIDFilter

  # Filter by the object’s `timestamp` field.
  timestamp: DatetimeFilter

  # Filter by the object’s `surface` field.
  surface: UUIDFilter

  # Filter by the object’s `data` field.
  data: JSONFilter

  # Filter by the object’s `surfaceBySurface` relation.
  surfaceBySurface: SurfaceFilter

  # A related `surfaceBySurface` exists.
  surfaceBySurfaceExists: Boolean

  # Checks for all expressions in this list.
  and: [CylinderPeriodicAsymptoticFilter!]

  # Checks for any expressions in this list.
  or: [CylinderPeriodicAsymptoticFilter!]

  # Negates the expression.
  not: CylinderPeriodicAsymptoticFilter
}

# An input for mutations affecting `CylinderPeriodicAsymptotic`
input CylinderPeriodicAsymptoticInput {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON!
}

# Represents an update to a `CylinderPeriodicAsymptotic`. Fields that are set will be updated.
input CylinderPeriodicAsymptoticPatch {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON
}

# A connection to a list of `CylinderPeriodicAsymptotic` values.
type CylinderPeriodicAsymptoticsConnection {
  # A list of `CylinderPeriodicAsymptotic` objects.
  nodes: [CylinderPeriodicAsymptotic]!

  # A list of edges which contains the `CylinderPeriodicAsymptotic` and cursor to aid in pagination.
  edges: [CylinderPeriodicAsymptoticsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `CylinderPeriodicAsymptotic` you could get from the connection.
  totalCount: Int!
}

# A `CylinderPeriodicAsymptotic` edge in the connection.
type CylinderPeriodicAsymptoticsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `CylinderPeriodicAsymptotic` at the end of the edge.
  node: CylinderPeriodicAsymptotic
}

# Methods to use when ordering `CylinderPeriodicAsymptotic`.
enum CylinderPeriodicAsymptoticsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  SURFACE_ASC
  SURFACE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
input DatetimeFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Datetime

  # Not equal to the specified value.
  notEqualTo: Datetime

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Datetime

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Datetime

  # Included in the specified list.
  in: [Datetime!]

  # Not included in the specified list.
  notIn: [Datetime!]

  # Less than the specified value.
  lessThan: Datetime

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Datetime

  # Greater than the specified value.
  greaterThan: Datetime

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Datetime
}

# All input for the `deleteBoshernitzanConjectureById` mutation.
input DeleteBoshernitzanConjectureByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: UUID!
}

# All input for the `deleteBoshernitzanConjecture` mutation.
input DeleteBoshernitzanConjectureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `BoshernitzanConjecture` to be deleted.
  nodeId: ID!
}

# The output of our delete `BoshernitzanConjecture` mutation.
type DeleteBoshernitzanConjecturePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `BoshernitzanConjecture` that was deleted by this mutation.
  boshernitzanConjecture: BoshernitzanConjecture
  deletedBoshernitzanConjectureId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `BoshernitzanConjecture`.
  surfaceBySurface: Surface

  # An edge for our `BoshernitzanConjecture`. May be used by Relay 1.
  boshernitzanConjectureEdge(
    # The method to use when ordering `BoshernitzanConjecture`.
    orderBy: [BoshernitzanConjecturesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BoshernitzanConjecturesEdge
}

# All input for the `deleteCompletelyCylinderPeriodicById` mutation.
input DeleteCompletelyCylinderPeriodicByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: UUID!
}

# All input for the `deleteCompletelyCylinderPeriodic` mutation.
input DeleteCompletelyCylinderPeriodicInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `CompletelyCylinderPeriodic` to be deleted.
  nodeId: ID!
}

# The output of our delete `CompletelyCylinderPeriodic` mutation.
type DeleteCompletelyCylinderPeriodicPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `CompletelyCylinderPeriodic` that was deleted by this mutation.
  completelyCylinderPeriodic: CompletelyCylinderPeriodic
  deletedCompletelyCylinderPeriodicId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `CompletelyCylinderPeriodic`.
  surfaceBySurface: Surface

  # An edge for our `CompletelyCylinderPeriodic`. May be used by Relay 1.
  completelyCylinderPeriodicEdge(
    # The method to use when ordering `CompletelyCylinderPeriodic`.
    orderBy: [CompletelyCylinderPeriodicsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompletelyCylinderPeriodicsEdge
}

# All input for the `deleteCylinderPeriodicAsymptoticById` mutation.
input DeleteCylinderPeriodicAsymptoticByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: UUID!
}

# All input for the `deleteCylinderPeriodicAsymptotic` mutation.
input DeleteCylinderPeriodicAsymptoticInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `CylinderPeriodicAsymptotic` to be deleted.
  nodeId: ID!
}

# The output of our delete `CylinderPeriodicAsymptotic` mutation.
type DeleteCylinderPeriodicAsymptoticPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `CylinderPeriodicAsymptotic` that was deleted by this mutation.
  cylinderPeriodicAsymptotic: CylinderPeriodicAsymptotic
  deletedCylinderPeriodicAsymptoticId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `CylinderPeriodicAsymptotic`.
  surfaceBySurface: Surface

  # An edge for our `CylinderPeriodicAsymptotic`. May be used by Relay 1.
  cylinderPeriodicAsymptoticEdge(
    # The method to use when ordering `CylinderPeriodicAsymptotic`.
    orderBy: [CylinderPeriodicAsymptoticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CylinderPeriodicAsymptoticsEdge
}

# All input for the `deleteFlowDecompositionById` mutation.
input DeleteFlowDecompositionByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: UUID!
}

# All input for the `deleteFlowDecomposition` mutation.
input DeleteFlowDecompositionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FlowDecomposition` to be deleted.
  nodeId: ID!
}

# The output of our delete `FlowDecomposition` mutation.
type DeleteFlowDecompositionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FlowDecomposition` that was deleted by this mutation.
  flowDecomposition: FlowDecomposition
  deletedFlowDecompositionId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `FlowDecomposition`.
  surfaceBySurface: Surface

  # An edge for our `FlowDecomposition`. May be used by Relay 1.
  flowDecompositionEdge(
    # The method to use when ordering `FlowDecomposition`.
    orderBy: [FlowDecompositionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FlowDecompositionsEdge
}

# All input for the `deleteOrbitClosureById` mutation.
input DeleteOrbitClosureByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: UUID!
}

# All input for the `deleteOrbitClosure` mutation.
input DeleteOrbitClosureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `OrbitClosure` to be deleted.
  nodeId: ID!
}

# The output of our delete `OrbitClosure` mutation.
type DeleteOrbitClosurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `OrbitClosure` that was deleted by this mutation.
  orbitClosure: OrbitClosure
  deletedOrbitClosureId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `OrbitClosure`.
  surfaceBySurface: Surface

  # An edge for our `OrbitClosure`. May be used by Relay 1.
  orbitClosureEdge(
    # The method to use when ordering `OrbitClosure`.
    orderBy: [OrbitClosuresOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrbitClosuresEdge
}

# All input for the `deleteSurfaceById` mutation.
input DeleteSurfaceByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: UUID!
}

# All input for the `deleteSurface` mutation.
input DeleteSurfaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Surface` to be deleted.
  nodeId: ID!
}

# The output of our delete `Surface` mutation.
type DeleteSurfacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Surface` that was deleted by this mutation.
  surface: Surface
  deletedSurfaceId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Surface`. May be used by Relay 1.
  surfaceEdge(
    # The method to use when ordering `Surface`.
    orderBy: [SurfacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SurfacesEdge
}

# All input for the `deleteUndeterminedIntervalExchangeTransformationById` mutation.
input DeleteUndeterminedIntervalExchangeTransformationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: UUID!
}

# All input for the `deleteUndeterminedIntervalExchangeTransformation` mutation.
input DeleteUndeterminedIntervalExchangeTransformationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UndeterminedIntervalExchangeTransformation` to be deleted.
  nodeId: ID!
}

# The output of our delete `UndeterminedIntervalExchangeTransformation` mutation.
type DeleteUndeterminedIntervalExchangeTransformationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UndeterminedIntervalExchangeTransformation` that was deleted by this mutation.
  undeterminedIntervalExchangeTransformation: UndeterminedIntervalExchangeTransformation
  deletedUndeterminedIntervalExchangeTransformationId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `UndeterminedIntervalExchangeTransformation`.
  surfaceBySurface: Surface

  # An edge for our `UndeterminedIntervalExchangeTransformation`. May be used by Relay 1.
  undeterminedIntervalExchangeTransformationEdge(
    # The method to use when ordering `UndeterminedIntervalExchangeTransformation`.
    orderBy: [UndeterminedIntervalExchangeTransformationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UndeterminedIntervalExchangeTransformationsEdge
}

# All input for the `deleteUserByEmail` mutation.
input DeleteUserByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  email: String!
}

# All input for the `deleteUserById` mutation.
input DeleteUserByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteUser` mutation.
input DeleteUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be deleted.
  nodeId: ID!
}

# The output of our delete `User` mutation.
type DeleteUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was deleted by this mutation.
  user: User
  deletedUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

type FlowDecomposition implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: UUID!
  timestamp: Datetime!
  surface: UUID
  data: JSON!

  # Reads a single `Surface` that is related to this `FlowDecomposition`.
  surfaceBySurface: Surface
  cylinders: Int
  minimal: Int
  undetermined: Int
}

# A condition to be used against `FlowDecomposition` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FlowDecompositionCondition {
  # Checks for equality with the object’s `id` field.
  id: UUID

  # Checks for equality with the object’s `timestamp` field.
  timestamp: Datetime

  # Checks for equality with the object’s `surface` field.
  surface: UUID

  # Checks for equality with the object’s `data` field.
  data: JSON
}

# A filter to be used against `FlowDecomposition` object types. All fields are combined with a logical ‘and.’
input FlowDecompositionFilter {
  # Filter by the object’s `id` field.
  id: UUIDFilter

  # Filter by the object’s `timestamp` field.
  timestamp: DatetimeFilter

  # Filter by the object’s `surface` field.
  surface: UUIDFilter

  # Filter by the object’s `data` field.
  data: JSONFilter

  # Filter by the object’s `cylinders` field.
  cylinders: IntFilter

  # Filter by the object’s `minimal` field.
  minimal: IntFilter

  # Filter by the object’s `undetermined` field.
  undetermined: IntFilter

  # Filter by the object’s `surfaceBySurface` relation.
  surfaceBySurface: SurfaceFilter

  # A related `surfaceBySurface` exists.
  surfaceBySurfaceExists: Boolean

  # Checks for all expressions in this list.
  and: [FlowDecompositionFilter!]

  # Checks for any expressions in this list.
  or: [FlowDecompositionFilter!]

  # Negates the expression.
  not: FlowDecompositionFilter
}

# An input for mutations affecting `FlowDecomposition`
input FlowDecompositionInput {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON!
}

# Represents an update to a `FlowDecomposition`. Fields that are set will be updated.
input FlowDecompositionPatch {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON
}

# A connection to a list of `FlowDecomposition` values.
type FlowDecompositionsConnection {
  # A list of `FlowDecomposition` objects.
  nodes: [FlowDecomposition]!

  # A list of edges which contains the `FlowDecomposition` and cursor to aid in pagination.
  edges: [FlowDecompositionsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FlowDecomposition` you could get from the connection.
  totalCount: Int!
}

# A `FlowDecomposition` edge in the connection.
type FlowDecompositionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FlowDecomposition` at the end of the edge.
  node: FlowDecomposition
}

# Methods to use when ordering `FlowDecomposition`.
enum FlowDecompositionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  SURFACE_ASC
  SURFACE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A filter to be used against Int fields. All fields are combined with a logical ‘and.’
input IntFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Int

  # Not equal to the specified value.
  notEqualTo: Int

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Int

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Int

  # Included in the specified list.
  in: [Int!]

  # Not included in the specified list.
  notIn: [Int!]

  # Less than the specified value.
  lessThan: Int

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Int

  # Greater than the specified value.
  greaterThan: Int

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Int
}

# A filter to be used against Int List fields. All fields are combined with a logical ‘and.’
input IntListFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: [Int]

  # Not equal to the specified value.
  notEqualTo: [Int]

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: [Int]

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: [Int]

  # Less than the specified value.
  lessThan: [Int]

  # Less than or equal to the specified value.
  lessThanOrEqualTo: [Int]

  # Greater than the specified value.
  greaterThan: [Int]

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: [Int]

  # Contains the specified list of values.
  contains: [Int]

  # Contained by the specified list of values.
  containedBy: [Int]

  # Overlaps the specified list of values.
  overlaps: [Int]

  # Any array item is equal to the specified value.
  anyEqualTo: Int

  # Any array item is not equal to the specified value.
  anyNotEqualTo: Int

  # Any array item is less than the specified value.
  anyLessThan: Int

  # Any array item is less than or equal to the specified value.
  anyLessThanOrEqualTo: Int

  # Any array item is greater than the specified value.
  anyGreaterThan: Int

  # Any array item is greater than or equal to the specified value.
  anyGreaterThanOrEqualTo: Int
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
input JSONFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: JSON

  # Not equal to the specified value.
  notEqualTo: JSON

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: JSON

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: JSON

  # Included in the specified list.
  in: [JSON!]

  # Not included in the specified list.
  notIn: [JSON!]

  # Less than the specified value.
  lessThan: JSON

  # Less than or equal to the specified value.
  lessThanOrEqualTo: JSON

  # Greater than the specified value.
  greaterThan: JSON

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: JSON

  # Contains the specified JSON.
  contains: JSON

  # Contains the specified key.
  containsKey: String

  # Contains all of the specified keys.
  containsAllKeys: [String!]

  # Contains any of the specified keys.
  containsAnyKeys: [String!]

  # Contained by the specified JSON.
  containedBy: JSON
}

# A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
# which securely represents claims between two parties.
scalar JwtToken

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  # Creates a single `BoshernitzanConjecture`.
  createBoshernitzanConjecture(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateBoshernitzanConjectureInput!
  ): CreateBoshernitzanConjecturePayload

  # Creates a single `CompletelyCylinderPeriodic`.
  createCompletelyCylinderPeriodic(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateCompletelyCylinderPeriodicInput!
  ): CreateCompletelyCylinderPeriodicPayload

  # Creates a single `CylinderPeriodicAsymptotic`.
  createCylinderPeriodicAsymptotic(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateCylinderPeriodicAsymptoticInput!
  ): CreateCylinderPeriodicAsymptoticPayload

  # Creates a single `FlowDecomposition`.
  createFlowDecomposition(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFlowDecompositionInput!
  ): CreateFlowDecompositionPayload

  # Creates a single `OrbitClosure`.
  createOrbitClosure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateOrbitClosureInput!
  ): CreateOrbitClosurePayload

  # Creates a single `Surface`.
  createSurface(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateSurfaceInput!
  ): CreateSurfacePayload

  # Creates a single `UndeterminedIntervalExchangeTransformation`.
  createUndeterminedIntervalExchangeTransformation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUndeterminedIntervalExchangeTransformationInput!
  ): CreateUndeterminedIntervalExchangeTransformationPayload

  # Creates a single `User`.
  createUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUserInput!
  ): CreateUserPayload

  # Updates a single `BoshernitzanConjecture` using its globally unique id and a patch.
  updateBoshernitzanConjecture(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBoshernitzanConjectureInput!
  ): UpdateBoshernitzanConjecturePayload

  # Updates a single `BoshernitzanConjecture` using a unique key and a patch.
  updateBoshernitzanConjectureById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBoshernitzanConjectureByIdInput!
  ): UpdateBoshernitzanConjecturePayload

  # Updates a single `CompletelyCylinderPeriodic` using its globally unique id and a patch.
  updateCompletelyCylinderPeriodic(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCompletelyCylinderPeriodicInput!
  ): UpdateCompletelyCylinderPeriodicPayload

  # Updates a single `CompletelyCylinderPeriodic` using a unique key and a patch.
  updateCompletelyCylinderPeriodicById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCompletelyCylinderPeriodicByIdInput!
  ): UpdateCompletelyCylinderPeriodicPayload

  # Updates a single `CylinderPeriodicAsymptotic` using its globally unique id and a patch.
  updateCylinderPeriodicAsymptotic(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCylinderPeriodicAsymptoticInput!
  ): UpdateCylinderPeriodicAsymptoticPayload

  # Updates a single `CylinderPeriodicAsymptotic` using a unique key and a patch.
  updateCylinderPeriodicAsymptoticById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCylinderPeriodicAsymptoticByIdInput!
  ): UpdateCylinderPeriodicAsymptoticPayload

  # Updates a single `FlowDecomposition` using its globally unique id and a patch.
  updateFlowDecomposition(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFlowDecompositionInput!
  ): UpdateFlowDecompositionPayload

  # Updates a single `FlowDecomposition` using a unique key and a patch.
  updateFlowDecompositionById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFlowDecompositionByIdInput!
  ): UpdateFlowDecompositionPayload

  # Updates a single `OrbitClosure` using its globally unique id and a patch.
  updateOrbitClosure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateOrbitClosureInput!
  ): UpdateOrbitClosurePayload

  # Updates a single `OrbitClosure` using a unique key and a patch.
  updateOrbitClosureById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateOrbitClosureByIdInput!
  ): UpdateOrbitClosurePayload

  # Updates a single `Surface` using its globally unique id and a patch.
  updateSurface(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSurfaceInput!
  ): UpdateSurfacePayload

  # Updates a single `Surface` using a unique key and a patch.
  updateSurfaceById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSurfaceByIdInput!
  ): UpdateSurfacePayload

  # Updates a single `UndeterminedIntervalExchangeTransformation` using its globally unique id and a patch.
  updateUndeterminedIntervalExchangeTransformation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUndeterminedIntervalExchangeTransformationInput!
  ): UpdateUndeterminedIntervalExchangeTransformationPayload

  # Updates a single `UndeterminedIntervalExchangeTransformation` using a unique key and a patch.
  updateUndeterminedIntervalExchangeTransformationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUndeterminedIntervalExchangeTransformationByIdInput!
  ): UpdateUndeterminedIntervalExchangeTransformationPayload

  # Updates a single `User` using its globally unique id and a patch.
  updateUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByEmailInput!
  ): UpdateUserPayload

  # Deletes a single `BoshernitzanConjecture` using its globally unique id.
  deleteBoshernitzanConjecture(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBoshernitzanConjectureInput!
  ): DeleteBoshernitzanConjecturePayload

  # Deletes a single `BoshernitzanConjecture` using a unique key.
  deleteBoshernitzanConjectureById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBoshernitzanConjectureByIdInput!
  ): DeleteBoshernitzanConjecturePayload

  # Deletes a single `CompletelyCylinderPeriodic` using its globally unique id.
  deleteCompletelyCylinderPeriodic(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCompletelyCylinderPeriodicInput!
  ): DeleteCompletelyCylinderPeriodicPayload

  # Deletes a single `CompletelyCylinderPeriodic` using a unique key.
  deleteCompletelyCylinderPeriodicById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCompletelyCylinderPeriodicByIdInput!
  ): DeleteCompletelyCylinderPeriodicPayload

  # Deletes a single `CylinderPeriodicAsymptotic` using its globally unique id.
  deleteCylinderPeriodicAsymptotic(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCylinderPeriodicAsymptoticInput!
  ): DeleteCylinderPeriodicAsymptoticPayload

  # Deletes a single `CylinderPeriodicAsymptotic` using a unique key.
  deleteCylinderPeriodicAsymptoticById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCylinderPeriodicAsymptoticByIdInput!
  ): DeleteCylinderPeriodicAsymptoticPayload

  # Deletes a single `FlowDecomposition` using its globally unique id.
  deleteFlowDecomposition(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFlowDecompositionInput!
  ): DeleteFlowDecompositionPayload

  # Deletes a single `FlowDecomposition` using a unique key.
  deleteFlowDecompositionById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFlowDecompositionByIdInput!
  ): DeleteFlowDecompositionPayload

  # Deletes a single `OrbitClosure` using its globally unique id.
  deleteOrbitClosure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteOrbitClosureInput!
  ): DeleteOrbitClosurePayload

  # Deletes a single `OrbitClosure` using a unique key.
  deleteOrbitClosureById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteOrbitClosureByIdInput!
  ): DeleteOrbitClosurePayload

  # Deletes a single `Surface` using its globally unique id.
  deleteSurface(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSurfaceInput!
  ): DeleteSurfacePayload

  # Deletes a single `Surface` using a unique key.
  deleteSurfaceById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSurfaceByIdInput!
  ): DeleteSurfacePayload

  # Deletes a single `UndeterminedIntervalExchangeTransformation` using its globally unique id.
  deleteUndeterminedIntervalExchangeTransformation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUndeterminedIntervalExchangeTransformationInput!
  ): DeleteUndeterminedIntervalExchangeTransformationPayload

  # Deletes a single `UndeterminedIntervalExchangeTransformation` using a unique key.
  deleteUndeterminedIntervalExchangeTransformationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUndeterminedIntervalExchangeTransformationByIdInput!
  ): DeleteUndeterminedIntervalExchangeTransformationPayload

  # Deletes a single `User` using its globally unique id.
  deleteUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByIdInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByEmailInput!
  ): DeleteUserPayload
  signin(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: SigninInput!
  ): SigninPayload
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
}

type OrbitClosure implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: UUID!
  timestamp: Datetime!
  surface: UUID
  data: JSON!

  # Reads a single `Surface` that is related to this `OrbitClosure`.
  surfaceBySurface: Surface
  dense: Boolean
}

# A condition to be used against `OrbitClosure` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input OrbitClosureCondition {
  # Checks for equality with the object’s `id` field.
  id: UUID

  # Checks for equality with the object’s `timestamp` field.
  timestamp: Datetime

  # Checks for equality with the object’s `surface` field.
  surface: UUID

  # Checks for equality with the object’s `data` field.
  data: JSON
}

# A filter to be used against `OrbitClosure` object types. All fields are combined with a logical ‘and.’
input OrbitClosureFilter {
  # Filter by the object’s `id` field.
  id: UUIDFilter

  # Filter by the object’s `timestamp` field.
  timestamp: DatetimeFilter

  # Filter by the object’s `surface` field.
  surface: UUIDFilter

  # Filter by the object’s `data` field.
  data: JSONFilter

  # Filter by the object’s `dense` field.
  dense: BooleanFilter

  # Filter by the object’s `surfaceBySurface` relation.
  surfaceBySurface: SurfaceFilter

  # A related `surfaceBySurface` exists.
  surfaceBySurfaceExists: Boolean

  # Checks for all expressions in this list.
  and: [OrbitClosureFilter!]

  # Checks for any expressions in this list.
  or: [OrbitClosureFilter!]

  # Negates the expression.
  not: OrbitClosureFilter
}

# An input for mutations affecting `OrbitClosure`
input OrbitClosureInput {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON!
}

# Represents an update to a `OrbitClosure`. Fields that are set will be updated.
input OrbitClosurePatch {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON
}

# A connection to a list of `OrbitClosure` values.
type OrbitClosuresConnection {
  # A list of `OrbitClosure` objects.
  nodes: [OrbitClosure]!

  # A list of edges which contains the `OrbitClosure` and cursor to aid in pagination.
  edges: [OrbitClosuresEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `OrbitClosure` you could get from the connection.
  totalCount: Int!
}

# A `OrbitClosure` edge in the connection.
type OrbitClosuresEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `OrbitClosure` at the end of the edge.
  node: OrbitClosure
}

# Methods to use when ordering `OrbitClosure`.
enum OrbitClosuresOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  SURFACE_ASC
  SURFACE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  nodeId: ID!

  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    nodeId: ID!
  ): Node

  # Reads and enables pagination through a set of `BoshernitzanConjecture`.
  allBoshernitzanConjectures(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `BoshernitzanConjecture`.
    orderBy: [BoshernitzanConjecturesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: BoshernitzanConjectureCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: BoshernitzanConjectureFilter
  ): BoshernitzanConjecturesConnection

  # Reads and enables pagination through a set of `CompletelyCylinderPeriodic`.
  allCompletelyCylinderPeriodics(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `CompletelyCylinderPeriodic`.
    orderBy: [CompletelyCylinderPeriodicsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: CompletelyCylinderPeriodicCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: CompletelyCylinderPeriodicFilter
  ): CompletelyCylinderPeriodicsConnection

  # Reads and enables pagination through a set of `CylinderPeriodicAsymptotic`.
  allCylinderPeriodicAsymptotics(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `CylinderPeriodicAsymptotic`.
    orderBy: [CylinderPeriodicAsymptoticsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: CylinderPeriodicAsymptoticCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: CylinderPeriodicAsymptoticFilter
  ): CylinderPeriodicAsymptoticsConnection

  # Reads and enables pagination through a set of `FlowDecomposition`.
  allFlowDecompositions(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FlowDecomposition`.
    orderBy: [FlowDecompositionsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: FlowDecompositionCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: FlowDecompositionFilter
  ): FlowDecompositionsConnection

  # Reads and enables pagination through a set of `OrbitClosure`.
  allOrbitClosures(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `OrbitClosure`.
    orderBy: [OrbitClosuresOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: OrbitClosureCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: OrbitClosureFilter
  ): OrbitClosuresConnection

  # Reads and enables pagination through a set of `Surface`.
  allSurfaces(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Surface`.
    orderBy: [SurfacesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: SurfaceCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: SurfaceFilter
  ): SurfacesConnection

  # Reads and enables pagination through a set of `UndeterminedIntervalExchangeTransformation`.
  allUndeterminedIntervalExchangeTransformations(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `UndeterminedIntervalExchangeTransformation`.
    orderBy: [UndeterminedIntervalExchangeTransformationsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: UndeterminedIntervalExchangeTransformationCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: UndeterminedIntervalExchangeTransformationFilter
  ): UndeterminedIntervalExchangeTransformationsConnection

  # Reads and enables pagination through a set of `User`.
  allUsers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: UserFilter
  ): UsersConnection
  boshernitzanConjectureById(id: UUID!): BoshernitzanConjecture
  completelyCylinderPeriodicById(id: UUID!): CompletelyCylinderPeriodic
  cylinderPeriodicAsymptoticById(id: UUID!): CylinderPeriodicAsymptotic
  flowDecompositionById(id: UUID!): FlowDecomposition
  orbitClosureById(id: UUID!): OrbitClosure
  surfaceById(id: UUID!): Surface
  undeterminedIntervalExchangeTransformationById(id: UUID!): UndeterminedIntervalExchangeTransformation
  userById(id: Int!): User
  userByEmail(email: String!): User

  # Reads a single `BoshernitzanConjecture` using its globally unique `ID`.
  boshernitzanConjecture(
    # The globally unique `ID` to be used in selecting a single `BoshernitzanConjecture`.
    nodeId: ID!
  ): BoshernitzanConjecture

  # Reads a single `CompletelyCylinderPeriodic` using its globally unique `ID`.
  completelyCylinderPeriodic(
    # The globally unique `ID` to be used in selecting a single `CompletelyCylinderPeriodic`.
    nodeId: ID!
  ): CompletelyCylinderPeriodic

  # Reads a single `CylinderPeriodicAsymptotic` using its globally unique `ID`.
  cylinderPeriodicAsymptotic(
    # The globally unique `ID` to be used in selecting a single `CylinderPeriodicAsymptotic`.
    nodeId: ID!
  ): CylinderPeriodicAsymptotic

  # Reads a single `FlowDecomposition` using its globally unique `ID`.
  flowDecomposition(
    # The globally unique `ID` to be used in selecting a single `FlowDecomposition`.
    nodeId: ID!
  ): FlowDecomposition

  # Reads a single `OrbitClosure` using its globally unique `ID`.
  orbitClosure(
    # The globally unique `ID` to be used in selecting a single `OrbitClosure`.
    nodeId: ID!
  ): OrbitClosure

  # Reads a single `Surface` using its globally unique `ID`.
  surface(
    # The globally unique `ID` to be used in selecting a single `Surface`.
    nodeId: ID!
  ): Surface

  # Reads a single `UndeterminedIntervalExchangeTransformation` using its globally unique `ID`.
  undeterminedIntervalExchangeTransformation(
    # The globally unique `ID` to be used in selecting a single `UndeterminedIntervalExchangeTransformation`.
    nodeId: ID!
  ): UndeterminedIntervalExchangeTransformation

  # Reads a single `User` using its globally unique `ID`.
  user(
    # The globally unique `ID` to be used in selecting a single `User`.
    nodeId: ID!
  ): User
}

# All input for the `signin` mutation.
input SigninInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  mail: String!
  password: String!
}

# The output of our `signin` mutation.
type SigninPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  jwtToken: JwtToken

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A filter to be used against String fields. All fields are combined with a logical ‘and.’
input StringFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: String

  # Not equal to the specified value.
  notEqualTo: String

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: String

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: String

  # Included in the specified list.
  in: [String!]

  # Not included in the specified list.
  notIn: [String!]

  # Less than the specified value.
  lessThan: String

  # Less than or equal to the specified value.
  lessThanOrEqualTo: String

  # Greater than the specified value.
  greaterThan: String

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: String

  # Contains the specified string (case-sensitive).
  includes: String

  # Does not contain the specified string (case-sensitive).
  notIncludes: String

  # Contains the specified string (case-insensitive).
  includesInsensitive: String

  # Does not contain the specified string (case-insensitive).
  notIncludesInsensitive: String

  # Starts with the specified string (case-sensitive).
  startsWith: String

  # Does not start with the specified string (case-sensitive).
  notStartsWith: String

  # Starts with the specified string (case-insensitive).
  startsWithInsensitive: String

  # Does not start with the specified string (case-insensitive).
  notStartsWithInsensitive: String

  # Ends with the specified string (case-sensitive).
  endsWith: String

  # Does not end with the specified string (case-sensitive).
  notEndsWith: String

  # Ends with the specified string (case-insensitive).
  endsWithInsensitive: String

  # Does not end with the specified string (case-insensitive).
  notEndsWithInsensitive: String

  # Matches the specified pattern (case-sensitive). An underscore (_) matches any
  # single character; a percent sign (%) matches any sequence of zero or more characters.
  like: String

  # Does not match the specified pattern (case-sensitive). An underscore (_)
  # matches any single character; a percent sign (%) matches any sequence of zero
  # or more characters.
  notLike: String

  # Matches the specified pattern (case-insensitive). An underscore (_) matches
  # any single character; a percent sign (%) matches any sequence of zero or more characters.
  likeInsensitive: String

  # Does not match the specified pattern (case-insensitive). An underscore (_)
  # matches any single character; a percent sign (%) matches any sequence of zero
  # or more characters.
  notLikeInsensitive: String

  # Equal to the specified value (case-insensitive).
  equalToInsensitive: String

  # Not equal to the specified value (case-insensitive).
  notEqualToInsensitive: String

  # Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  distinctFromInsensitive: String

  # Equal to the specified value, treating null like an ordinary value (case-insensitive).
  notDistinctFromInsensitive: String

  # Included in the specified list (case-insensitive).
  inInsensitive: [String!]

  # Not included in the specified list (case-insensitive).
  notInInsensitive: [String!]

  # Less than the specified value (case-insensitive).
  lessThanInsensitive: String

  # Less than or equal to the specified value (case-insensitive).
  lessThanOrEqualToInsensitive: String

  # Greater than the specified value (case-insensitive).
  greaterThanInsensitive: String

  # Greater than or equal to the specified value (case-insensitive).
  greaterThanOrEqualToInsensitive: String
}

type Surface implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: UUID!
  timestamp: Datetime!
  data: JSON!

  # Reads and enables pagination through a set of `OrbitClosure`.
  orbitClosuresBySurface(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `OrbitClosure`.
    orderBy: [OrbitClosuresOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: OrbitClosureCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: OrbitClosureFilter
  ): OrbitClosuresConnection!

  # Reads and enables pagination through a set of `FlowDecomposition`.
  flowDecompositionsBySurface(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FlowDecomposition`.
    orderBy: [FlowDecompositionsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: FlowDecompositionCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: FlowDecompositionFilter
  ): FlowDecompositionsConnection!

  # Reads and enables pagination through a set of `CompletelyCylinderPeriodic`.
  completelyCylinderPeriodicsBySurface(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `CompletelyCylinderPeriodic`.
    orderBy: [CompletelyCylinderPeriodicsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: CompletelyCylinderPeriodicCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: CompletelyCylinderPeriodicFilter
  ): CompletelyCylinderPeriodicsConnection!

  # Reads and enables pagination through a set of `UndeterminedIntervalExchangeTransformation`.
  undeterminedIntervalExchangeTransformationsBySurface(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `UndeterminedIntervalExchangeTransformation`.
    orderBy: [UndeterminedIntervalExchangeTransformationsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: UndeterminedIntervalExchangeTransformationCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: UndeterminedIntervalExchangeTransformationFilter
  ): UndeterminedIntervalExchangeTransformationsConnection!

  # Reads and enables pagination through a set of `CylinderPeriodicAsymptotic`.
  cylinderPeriodicAsymptoticsBySurface(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `CylinderPeriodicAsymptotic`.
    orderBy: [CylinderPeriodicAsymptoticsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: CylinderPeriodicAsymptoticCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: CylinderPeriodicAsymptoticFilter
  ): CylinderPeriodicAsymptoticsConnection!

  # Reads and enables pagination through a set of `BoshernitzanConjecture`.
  boshernitzanConjecturesBySurface(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `BoshernitzanConjecture`.
    orderBy: [BoshernitzanConjecturesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: BoshernitzanConjectureCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: BoshernitzanConjectureFilter
  ): BoshernitzanConjecturesConnection!
  angles: [Int]
  name: String
  vertices: Int
}

# A condition to be used against `Surface` object types. All fields are tested for equality and combined with a logical ‘and.’
input SurfaceCondition {
  # Checks for equality with the object’s `id` field.
  id: UUID

  # Checks for equality with the object’s `timestamp` field.
  timestamp: Datetime

  # Checks for equality with the object’s `data` field.
  data: JSON
}

# A filter to be used against `Surface` object types. All fields are combined with a logical ‘and.’
input SurfaceFilter {
  # Filter by the object’s `id` field.
  id: UUIDFilter

  # Filter by the object’s `timestamp` field.
  timestamp: DatetimeFilter

  # Filter by the object’s `data` field.
  data: JSONFilter

  # Filter by the object’s `angles` field.
  angles: IntListFilter

  # Filter by the object’s `name` field.
  name: StringFilter

  # Filter by the object’s `vertices` field.
  vertices: IntFilter

  # Filter by the object’s `orbitClosuresBySurface` relation.
  orbitClosuresBySurface: SurfaceToManyOrbitClosureFilter

  # Some related `orbitClosuresBySurface` exist.
  orbitClosuresBySurfaceExist: Boolean

  # Filter by the object’s `flowDecompositionsBySurface` relation.
  flowDecompositionsBySurface: SurfaceToManyFlowDecompositionFilter

  # Some related `flowDecompositionsBySurface` exist.
  flowDecompositionsBySurfaceExist: Boolean

  # Filter by the object’s `completelyCylinderPeriodicsBySurface` relation.
  completelyCylinderPeriodicsBySurface: SurfaceToManyCompletelyCylinderPeriodicFilter

  # Some related `completelyCylinderPeriodicsBySurface` exist.
  completelyCylinderPeriodicsBySurfaceExist: Boolean

  # Filter by the object’s `undeterminedIntervalExchangeTransformationsBySurface` relation.
  undeterminedIntervalExchangeTransformationsBySurface: SurfaceToManyUndeterminedIntervalExchangeTransformationFilter

  # Some related `undeterminedIntervalExchangeTransformationsBySurface` exist.
  undeterminedIntervalExchangeTransformationsBySurfaceExist: Boolean

  # Filter by the object’s `cylinderPeriodicAsymptoticsBySurface` relation.
  cylinderPeriodicAsymptoticsBySurface: SurfaceToManyCylinderPeriodicAsymptoticFilter

  # Some related `cylinderPeriodicAsymptoticsBySurface` exist.
  cylinderPeriodicAsymptoticsBySurfaceExist: Boolean

  # Filter by the object’s `boshernitzanConjecturesBySurface` relation.
  boshernitzanConjecturesBySurface: SurfaceToManyBoshernitzanConjectureFilter

  # Some related `boshernitzanConjecturesBySurface` exist.
  boshernitzanConjecturesBySurfaceExist: Boolean

  # Checks for all expressions in this list.
  and: [SurfaceFilter!]

  # Checks for any expressions in this list.
  or: [SurfaceFilter!]

  # Negates the expression.
  not: SurfaceFilter
}

# An input for mutations affecting `Surface`
input SurfaceInput {
  id: UUID
  timestamp: Datetime
  data: JSON!
}

# Represents an update to a `Surface`. Fields that are set will be updated.
input SurfacePatch {
  id: UUID
  timestamp: Datetime
  data: JSON
}

# A connection to a list of `Surface` values.
type SurfacesConnection {
  # A list of `Surface` objects.
  nodes: [Surface]!

  # A list of edges which contains the `Surface` and cursor to aid in pagination.
  edges: [SurfacesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Surface` you could get from the connection.
  totalCount: Int!
}

# A `Surface` edge in the connection.
type SurfacesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Surface` at the end of the edge.
  node: Surface
}

# Methods to use when ordering `Surface`.
enum SurfacesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A filter to be used against many `BoshernitzanConjecture` object types. All fields are combined with a logical ‘and.’
input SurfaceToManyBoshernitzanConjectureFilter {
  # Every related `BoshernitzanConjecture` matches the filter criteria. All fields are combined with a logical ‘and.’
  every: BoshernitzanConjectureFilter

  # Some related `BoshernitzanConjecture` matches the filter criteria. All fields are combined with a logical ‘and.’
  some: BoshernitzanConjectureFilter

  # No related `BoshernitzanConjecture` matches the filter criteria. All fields are combined with a logical ‘and.’
  none: BoshernitzanConjectureFilter
}

# A filter to be used against many `CompletelyCylinderPeriodic` object types. All fields are combined with a logical ‘and.’
input SurfaceToManyCompletelyCylinderPeriodicFilter {
  # Every related `CompletelyCylinderPeriodic` matches the filter criteria. All fields are combined with a logical ‘and.’
  every: CompletelyCylinderPeriodicFilter

  # Some related `CompletelyCylinderPeriodic` matches the filter criteria. All fields are combined with a logical ‘and.’
  some: CompletelyCylinderPeriodicFilter

  # No related `CompletelyCylinderPeriodic` matches the filter criteria. All fields are combined with a logical ‘and.’
  none: CompletelyCylinderPeriodicFilter
}

# A filter to be used against many `CylinderPeriodicAsymptotic` object types. All fields are combined with a logical ‘and.’
input SurfaceToManyCylinderPeriodicAsymptoticFilter {
  # Every related `CylinderPeriodicAsymptotic` matches the filter criteria. All fields are combined with a logical ‘and.’
  every: CylinderPeriodicAsymptoticFilter

  # Some related `CylinderPeriodicAsymptotic` matches the filter criteria. All fields are combined with a logical ‘and.’
  some: CylinderPeriodicAsymptoticFilter

  # No related `CylinderPeriodicAsymptotic` matches the filter criteria. All fields are combined with a logical ‘and.’
  none: CylinderPeriodicAsymptoticFilter
}

# A filter to be used against many `FlowDecomposition` object types. All fields are combined with a logical ‘and.’
input SurfaceToManyFlowDecompositionFilter {
  # Every related `FlowDecomposition` matches the filter criteria. All fields are combined with a logical ‘and.’
  every: FlowDecompositionFilter

  # Some related `FlowDecomposition` matches the filter criteria. All fields are combined with a logical ‘and.’
  some: FlowDecompositionFilter

  # No related `FlowDecomposition` matches the filter criteria. All fields are combined with a logical ‘and.’
  none: FlowDecompositionFilter
}

# A filter to be used against many `OrbitClosure` object types. All fields are combined with a logical ‘and.’
input SurfaceToManyOrbitClosureFilter {
  # Every related `OrbitClosure` matches the filter criteria. All fields are combined with a logical ‘and.’
  every: OrbitClosureFilter

  # Some related `OrbitClosure` matches the filter criteria. All fields are combined with a logical ‘and.’
  some: OrbitClosureFilter

  # No related `OrbitClosure` matches the filter criteria. All fields are combined with a logical ‘and.’
  none: OrbitClosureFilter
}

# A filter to be used against many `UndeterminedIntervalExchangeTransformation`
# object types. All fields are combined with a logical ‘and.’
input SurfaceToManyUndeterminedIntervalExchangeTransformationFilter {
  # Every related `UndeterminedIntervalExchangeTransformation` matches the filter
  # criteria. All fields are combined with a logical ‘and.’
  every: UndeterminedIntervalExchangeTransformationFilter

  # Some related `UndeterminedIntervalExchangeTransformation` matches the filter
  # criteria. All fields are combined with a logical ‘and.’
  some: UndeterminedIntervalExchangeTransformationFilter

  # No related `UndeterminedIntervalExchangeTransformation` matches the filter
  # criteria. All fields are combined with a logical ‘and.’
  none: UndeterminedIntervalExchangeTransformationFilter
}

type UndeterminedIntervalExchangeTransformation implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: UUID!
  timestamp: Datetime!
  surface: UUID
  data: JSON!

  # Reads a single `Surface` that is related to this `UndeterminedIntervalExchangeTransformation`.
  surfaceBySurface: Surface
  degree: Int
  intervals: Int
}

# A condition to be used against `UndeterminedIntervalExchangeTransformation`
# object types. All fields are tested for equality and combined with a logical ‘and.’
input UndeterminedIntervalExchangeTransformationCondition {
  # Checks for equality with the object’s `id` field.
  id: UUID

  # Checks for equality with the object’s `timestamp` field.
  timestamp: Datetime

  # Checks for equality with the object’s `surface` field.
  surface: UUID

  # Checks for equality with the object’s `data` field.
  data: JSON
}

# A filter to be used against `UndeterminedIntervalExchangeTransformation` object
# types. All fields are combined with a logical ‘and.’
input UndeterminedIntervalExchangeTransformationFilter {
  # Filter by the object’s `id` field.
  id: UUIDFilter

  # Filter by the object’s `timestamp` field.
  timestamp: DatetimeFilter

  # Filter by the object’s `surface` field.
  surface: UUIDFilter

  # Filter by the object’s `data` field.
  data: JSONFilter

  # Filter by the object’s `degree` field.
  degree: IntFilter

  # Filter by the object’s `intervals` field.
  intervals: IntFilter

  # Filter by the object’s `surfaceBySurface` relation.
  surfaceBySurface: SurfaceFilter

  # A related `surfaceBySurface` exists.
  surfaceBySurfaceExists: Boolean

  # Checks for all expressions in this list.
  and: [UndeterminedIntervalExchangeTransformationFilter!]

  # Checks for any expressions in this list.
  or: [UndeterminedIntervalExchangeTransformationFilter!]

  # Negates the expression.
  not: UndeterminedIntervalExchangeTransformationFilter
}

# An input for mutations affecting `UndeterminedIntervalExchangeTransformation`
input UndeterminedIntervalExchangeTransformationInput {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON!
}

# Represents an update to a `UndeterminedIntervalExchangeTransformation`. Fields that are set will be updated.
input UndeterminedIntervalExchangeTransformationPatch {
  id: UUID
  timestamp: Datetime
  surface: UUID
  data: JSON
}

# A connection to a list of `UndeterminedIntervalExchangeTransformation` values.
type UndeterminedIntervalExchangeTransformationsConnection {
  # A list of `UndeterminedIntervalExchangeTransformation` objects.
  nodes: [UndeterminedIntervalExchangeTransformation]!

  # A list of edges which contains the `UndeterminedIntervalExchangeTransformation` and cursor to aid in pagination.
  edges: [UndeterminedIntervalExchangeTransformationsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `UndeterminedIntervalExchangeTransformation` you could get from the connection.
  totalCount: Int!
}

# A `UndeterminedIntervalExchangeTransformation` edge in the connection.
type UndeterminedIntervalExchangeTransformationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `UndeterminedIntervalExchangeTransformation` at the end of the edge.
  node: UndeterminedIntervalExchangeTransformation
}

# Methods to use when ordering `UndeterminedIntervalExchangeTransformation`.
enum UndeterminedIntervalExchangeTransformationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  SURFACE_ASC
  SURFACE_DESC
  DATA_ASC
  DATA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# All input for the `updateBoshernitzanConjectureById` mutation.
input UpdateBoshernitzanConjectureByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `BoshernitzanConjecture` being updated.
  boshernitzanConjecturePatch: BoshernitzanConjecturePatch!
  id: UUID!
}

# All input for the `updateBoshernitzanConjecture` mutation.
input UpdateBoshernitzanConjectureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `BoshernitzanConjecture` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `BoshernitzanConjecture` being updated.
  boshernitzanConjecturePatch: BoshernitzanConjecturePatch!
}

# The output of our update `BoshernitzanConjecture` mutation.
type UpdateBoshernitzanConjecturePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `BoshernitzanConjecture` that was updated by this mutation.
  boshernitzanConjecture: BoshernitzanConjecture

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `BoshernitzanConjecture`.
  surfaceBySurface: Surface

  # An edge for our `BoshernitzanConjecture`. May be used by Relay 1.
  boshernitzanConjectureEdge(
    # The method to use when ordering `BoshernitzanConjecture`.
    orderBy: [BoshernitzanConjecturesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BoshernitzanConjecturesEdge
}

# All input for the `updateCompletelyCylinderPeriodicById` mutation.
input UpdateCompletelyCylinderPeriodicByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `CompletelyCylinderPeriodic` being updated.
  completelyCylinderPeriodicPatch: CompletelyCylinderPeriodicPatch!
  id: UUID!
}

# All input for the `updateCompletelyCylinderPeriodic` mutation.
input UpdateCompletelyCylinderPeriodicInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `CompletelyCylinderPeriodic` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `CompletelyCylinderPeriodic` being updated.
  completelyCylinderPeriodicPatch: CompletelyCylinderPeriodicPatch!
}

# The output of our update `CompletelyCylinderPeriodic` mutation.
type UpdateCompletelyCylinderPeriodicPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `CompletelyCylinderPeriodic` that was updated by this mutation.
  completelyCylinderPeriodic: CompletelyCylinderPeriodic

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `CompletelyCylinderPeriodic`.
  surfaceBySurface: Surface

  # An edge for our `CompletelyCylinderPeriodic`. May be used by Relay 1.
  completelyCylinderPeriodicEdge(
    # The method to use when ordering `CompletelyCylinderPeriodic`.
    orderBy: [CompletelyCylinderPeriodicsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompletelyCylinderPeriodicsEdge
}

# All input for the `updateCylinderPeriodicAsymptoticById` mutation.
input UpdateCylinderPeriodicAsymptoticByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `CylinderPeriodicAsymptotic` being updated.
  cylinderPeriodicAsymptoticPatch: CylinderPeriodicAsymptoticPatch!
  id: UUID!
}

# All input for the `updateCylinderPeriodicAsymptotic` mutation.
input UpdateCylinderPeriodicAsymptoticInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `CylinderPeriodicAsymptotic` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `CylinderPeriodicAsymptotic` being updated.
  cylinderPeriodicAsymptoticPatch: CylinderPeriodicAsymptoticPatch!
}

# The output of our update `CylinderPeriodicAsymptotic` mutation.
type UpdateCylinderPeriodicAsymptoticPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `CylinderPeriodicAsymptotic` that was updated by this mutation.
  cylinderPeriodicAsymptotic: CylinderPeriodicAsymptotic

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `CylinderPeriodicAsymptotic`.
  surfaceBySurface: Surface

  # An edge for our `CylinderPeriodicAsymptotic`. May be used by Relay 1.
  cylinderPeriodicAsymptoticEdge(
    # The method to use when ordering `CylinderPeriodicAsymptotic`.
    orderBy: [CylinderPeriodicAsymptoticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CylinderPeriodicAsymptoticsEdge
}

# All input for the `updateFlowDecompositionById` mutation.
input UpdateFlowDecompositionByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `FlowDecomposition` being updated.
  flowDecompositionPatch: FlowDecompositionPatch!
  id: UUID!
}

# All input for the `updateFlowDecomposition` mutation.
input UpdateFlowDecompositionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FlowDecomposition` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `FlowDecomposition` being updated.
  flowDecompositionPatch: FlowDecompositionPatch!
}

# The output of our update `FlowDecomposition` mutation.
type UpdateFlowDecompositionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FlowDecomposition` that was updated by this mutation.
  flowDecomposition: FlowDecomposition

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `FlowDecomposition`.
  surfaceBySurface: Surface

  # An edge for our `FlowDecomposition`. May be used by Relay 1.
  flowDecompositionEdge(
    # The method to use when ordering `FlowDecomposition`.
    orderBy: [FlowDecompositionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FlowDecompositionsEdge
}

# All input for the `updateOrbitClosureById` mutation.
input UpdateOrbitClosureByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `OrbitClosure` being updated.
  orbitClosurePatch: OrbitClosurePatch!
  id: UUID!
}

# All input for the `updateOrbitClosure` mutation.
input UpdateOrbitClosureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `OrbitClosure` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `OrbitClosure` being updated.
  orbitClosurePatch: OrbitClosurePatch!
}

# The output of our update `OrbitClosure` mutation.
type UpdateOrbitClosurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `OrbitClosure` that was updated by this mutation.
  orbitClosure: OrbitClosure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `OrbitClosure`.
  surfaceBySurface: Surface

  # An edge for our `OrbitClosure`. May be used by Relay 1.
  orbitClosureEdge(
    # The method to use when ordering `OrbitClosure`.
    orderBy: [OrbitClosuresOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrbitClosuresEdge
}

# All input for the `updateSurfaceById` mutation.
input UpdateSurfaceByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Surface` being updated.
  surfacePatch: SurfacePatch!
  id: UUID!
}

# All input for the `updateSurface` mutation.
input UpdateSurfaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Surface` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Surface` being updated.
  surfacePatch: SurfacePatch!
}

# The output of our update `Surface` mutation.
type UpdateSurfacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Surface` that was updated by this mutation.
  surface: Surface

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Surface`. May be used by Relay 1.
  surfaceEdge(
    # The method to use when ordering `Surface`.
    orderBy: [SurfacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SurfacesEdge
}

# All input for the `updateUndeterminedIntervalExchangeTransformationById` mutation.
input UpdateUndeterminedIntervalExchangeTransformationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `UndeterminedIntervalExchangeTransformation` being updated.
  undeterminedIntervalExchangeTransformationPatch: UndeterminedIntervalExchangeTransformationPatch!
  id: UUID!
}

# All input for the `updateUndeterminedIntervalExchangeTransformation` mutation.
input UpdateUndeterminedIntervalExchangeTransformationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UndeterminedIntervalExchangeTransformation` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `UndeterminedIntervalExchangeTransformation` being updated.
  undeterminedIntervalExchangeTransformationPatch: UndeterminedIntervalExchangeTransformationPatch!
}

# The output of our update `UndeterminedIntervalExchangeTransformation` mutation.
type UpdateUndeterminedIntervalExchangeTransformationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UndeterminedIntervalExchangeTransformation` that was updated by this mutation.
  undeterminedIntervalExchangeTransformation: UndeterminedIntervalExchangeTransformation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Surface` that is related to this `UndeterminedIntervalExchangeTransformation`.
  surfaceBySurface: Surface

  # An edge for our `UndeterminedIntervalExchangeTransformation`. May be used by Relay 1.
  undeterminedIntervalExchangeTransformationEdge(
    # The method to use when ordering `UndeterminedIntervalExchangeTransformation`.
    orderBy: [UndeterminedIntervalExchangeTransformationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UndeterminedIntervalExchangeTransformationsEdge
}

# All input for the `updateUserByEmail` mutation.
input UpdateUserByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
  email: String!
}

# All input for the `updateUserById` mutation.
input UpdateUserByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
  id: Int!
}

# All input for the `updateUser` mutation.
input UpdateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
}

# The output of our update `User` mutation.
type UpdateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was updated by this mutation.
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

type User implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  email: String!
  password: String!
}

# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
input UserCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `password` field.
  password: String
}

# A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
input UserFilter {
  # Filter by the object’s `id` field.
  id: IntFilter

  # Filter by the object’s `email` field.
  email: StringFilter

  # Filter by the object’s `password` field.
  password: StringFilter

  # Checks for all expressions in this list.
  and: [UserFilter!]

  # Checks for any expressions in this list.
  or: [UserFilter!]

  # Negates the expression.
  not: UserFilter
}

# An input for mutations affecting `User`
input UserInput {
  id: Int
  email: String!
  password: String!
}

# Represents an update to a `User`. Fields that are set will be updated.
input UserPatch {
  id: Int
  email: String
  password: String
}

# A connection to a list of `User` values.
type UsersConnection {
  # A list of `User` objects.
  nodes: [User]!

  # A list of edges which contains the `User` and cursor to aid in pagination.
  edges: [UsersEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `User` you could get from the connection.
  totalCount: Int!
}

# A `User` edge in the connection.
type UsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `User` at the end of the edge.
  node: User
}

# Methods to use when ordering `User`.
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar UUID

# A filter to be used against UUID fields. All fields are combined with a logical ‘and.’
input UUIDFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: UUID

  # Not equal to the specified value.
  notEqualTo: UUID

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: UUID

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: UUID

  # Included in the specified list.
  in: [UUID!]

  # Not included in the specified list.
  notIn: [UUID!]

  # Less than the specified value.
  lessThan: UUID

  # Less than or equal to the specified value.
  lessThanOrEqualTo: UUID

  # Greater than the specified value.
  greaterThan: UUID

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: UUID
}

